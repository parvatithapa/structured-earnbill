/*
 * JBILLING CONFIDENTIAL
 * _____________________
 *
 * [2003] - [2012] Enterprise jBilling Software Ltd.
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Enterprise jBilling Software.
 * The intellectual and technical concepts contained
 * herein are proprietary to Enterprise jBilling Software
 * and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden.
 */

package com.sapienter.jbilling.server.provisioning;

import javax.jms.MapMessage;
import javax.jms.Message;
import javax.jms.MessageListener;

import com.sapienter.jbilling.common.SessionInternalError;
import com.sapienter.jbilling.server.provisioning.db.ProvisioningCommandDAS;
import com.sapienter.jbilling.server.provisioning.db.ProvisioningCommandDTO;
import com.sapienter.jbilling.server.provisioning.db.ProvisioningRequestDAS;
import com.sapienter.jbilling.server.provisioning.event.CommandStatusUpdateEvent;
import com.sapienter.jbilling.server.system.event.EventManager;
import com.sapienter.jbilling.server.timezone.TimezoneHelper;

import com.sapienter.jbilling.common.FormatLogger;
import com.sapienter.jbilling.server.util.Constants;
import com.sapienter.jbilling.server.util.Context;

import org.slf4j.LoggerFactory;
import org.slf4j.Logger;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import java.lang.invoke.MethodHandles;
import java.util.Date;

/**
 * Tests responses from the external provisioning module. Receives 
 * messages via JMS. Note that ProvisioningCommandsMDB also processes
 * these messages. See also TestExternalProvisioningTask, 
 * ProvisioningTest, provisioning_commands.drl and jbilling-provisioning.xml.
 * Configured in jbilling-jms.xml. 
 */
@Transactional( propagation = Propagation.REQUIRED )
public class TestExternalProvisioningMDB extends ClusterAwareProvisioningMDB {
    private static final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());

    private int count = 0; // what message is expected to be received
    private boolean fail = false; // whether the test has failed

    @Override
    public void doOnMessage(Message message) {
        try {
            MapMessage myMessage = (MapMessage) message;

            logger.debug("Got a message. Command: {}",
                    myMessage.getStringProperty("in_commandId"));

            // only test messages generated by the result or cai test commands
            if (myMessage.getStringProperty("in_command")
                    .equals("result_test")) {
                testExternalProvisioningTask(myMessage);
            } else if (myMessage.getStringProperty("in_command")
                    .equals("cai_test")) {
                testCAIProvisioningTask(myMessage);
            }else if (myMessage.getStringProperty("in_command")
                    .equals("mmsc_test")) {
                testMMSCProvisioningTask(myMessage);

            }
        } catch (Exception e) {
            logger.error("Error processing message", e);
        }
    }

    public void testExternalProvisioningTask(MapMessage message) {
        try {
            // only sucessful after receiving the last expected message
            // sucessfully (and no other tests failed).
            boolean success = false;

            String result = message.getStringProperty("out_result");
            switch (count) {
                case 0:
                    if (!result.equals("success")) {
                        fail = true;
                        logger.error("Expected a result of 'success', but got '{}'" ,
                                result);
                    } else {
                        logger.debug("Got 'success' result");
                    }
                    break;

                case 1:
                    if (!result.equals("unavailable")) {
                        fail = true;
                        logger.error("Expected a result of 'unavailable', but got '{}' ", result);
                    } else {
                        logger.debug("Got 'unavailable' result");
                        String exception = message.getStringProperty("exception");
                        if (exception == null) {
                            fail = true;
                            logger.error("Expected an exception property.");
                        } else if (!exception.equals("com.sapienter.jbilling.server.pluggableTask.TaskException: Test Exception")) {
                            fail = true;
                            logger.error("Expected a Task Exception, but got: {}" ,
                                exception);
                        } else {
                            logger.debug("Got a Task Exception");
                        }
                    }
                    break;

                case 2:
                    if (!result.equals("fail")) {
                        fail = true;
                        logger.error("Expected a result of 'fail', but got '{}'",
                                result);
                    } else {
                        logger.debug("Got 'fail' result");
                        if (!fail) {
                            success = true;
                        }
                    }
                    break;

                default:
                    fail = true;
                    logger.error("Too many messages.");
                    break;
            }

            String in_order_line_id_str = message.getStringProperty("in_order_line_id");
            Integer orderLineId = null;
            try {
                orderLineId = Integer.parseInt(in_order_line_id_str.trim());
            } catch (Exception e) {}


            // Set the order line's provisioning status to 'ACTIVE' if
            // test is complete, others to 'FAILED' (overrides
            // ProvisioningCommandsMDB).
            if (orderLineId != null) {
                if (success) {
                    logger.debug("Provisioning status of order line id {} updated to ACTIVE" ,
                            orderLineId );
                    updateProvisioningStatus(orderLineId,
                            Constants.PROVISIONING_STATUS_ACTIVE);
                } else {
                    logger.debug("Provisioning status of order line id {} updated to FAILED",orderLineId);
                    updateProvisioningStatus(orderLineId,
                            Constants.PROVISIONING_STATUS_FAILED);
                }
            } else {
                updateProvisioningCommandStatus(message);
            }

            count++;

        } catch (Exception e) {
            logger.error("processing provisioning command", e);
        }
    }

    private void testCAIProvisioningTask(MapMessage message) {
        try {
            boolean success = true;

            String value = message.getStringProperty("out_result");
            if (!value.equals("success")) {
                success = false;
                logger.error("Expected a result of 'success', but got '{}'",
                        value);
            } else {
                logger.debug("Got 'success' result");
            }

            value = message.getStringProperty("out_RESP");
            if (!value.equals("0")) {
                success = false;
                logger.error("Expected a RESP of '0', but got '{}'" , value);
            } else {
                logger.debug("Got '0' RESP");
            }

            value = message.getStringProperty("out_TRANSID");
            if (value.length() != 32) {
                success = false;
                logger.error("Expected a TRANSID length of 32. Got: '{}'",
                        value);
            } else {
                logger.debug("Got TRANSID with a length of 32");
            }

            value = message.getStringProperty("out_MSISDN");
            if (!value.equals("98765")) {
                success = false;
                logger.error("Expected returned 'MSISDN' to have a value of '98765', but got '{}'",value);
            } else {
                logger.debug("Got returned field 'MSISDN' == '98765");
            }

            value = message.getStringProperty("out_IMSI");
            if (value != null) {
                success = false;
                logger.error("Expected 'IMSI' to have been removed by the CAIProvisioningTask 'remove' parameter and not returned by TestCommunication. Value: '{}'",
                        value);
            } else {
                logger.debug("IMSI field was removed by CAIProvisioningTask and not returned by TestCommunication.");
            }

            String in_order_line_id_str = message.getStringProperty("in_order_line_id");
            Integer orderLineId = null;
            try {
                orderLineId = Integer.parseInt(in_order_line_id_str.trim());
            } catch (Exception e) {}

            // Set the order line's provisioning status to 'ACTIVE' if
            // test is successful, others to 'FAILED' (overrides
            // ProvisioningCommandsMDB).
            if (orderLineId != null) {
                if (success) {
                    logger.debug("Provisioning status of order line id {} updated to ACTIVE",
                            orderLineId);
                    updateProvisioningStatus(orderLineId,
                            Constants.PROVISIONING_STATUS_ACTIVE);
                } else {
                    logger.debug("Provisioning status of order line id {} updated to FAILED",
                            orderLineId);
                    updateProvisioningStatus(orderLineId,
                            Constants.PROVISIONING_STATUS_FAILED);
                }
            } else {
                updateProvisioningCommandStatus(message);
            }
        } catch (Exception e) {
            logger.error("processing cai provisioning command", e);
        }
    }

    private void testMMSCProvisioningTask(MapMessage message) {
        try {
            boolean success = true;

            String value = message.getStringProperty("out_result");
            if (value == null || !value.equals("success")) {
                success = false;
                logger.error("Expected a result of 'success', but got '{}'",value);
            } else {
                logger.debug("Got 'success' result");
            }

            value = message.getStringProperty("out_statusCode");
            if (value == null || !value.equals("0")) {
                success = false;
                logger.error("Expected a statusCode of '0', but got '{}'" , value);
            } else {
                logger.debug("Got '0' statusCode");
            }

            value = message.getStringProperty("out_transactionId");
            if (value == null || value.length() != 36) {
                success = false;
                logger.error("Expected a transactionId length of 36. Got: '{}'" , value);
            } else {
                logger.debug("Got transactionId with a length of 36");
            }

            value = message.getStringProperty("out_statusMessage");
            if (value == null || !value.equals("Operation Performed Successfully")) {
                success = false;
                logger.error("Expected a statusMessage of 'Operation Performed Successfully'. But Got: '{}'", value);
            } else {
                logger.debug("Got statusMessage of 'Operation Performed Successfully' ");
            }

            String in_order_line_id_str = message.getStringProperty("in_order_line_id");
            Integer orderLineId = null;
            try {
                orderLineId = Integer.parseInt(in_order_line_id_str.trim());
            } catch (Exception e) {}

            // Set the order line's provisioning status to 'ACTIVE' if
            // test is successful, others to 'FAILED' (overrides
            // ProvisioningCommandsMDB).
            if (orderLineId != null) {
                if (success) {
                    logger.debug("Provisioning status of order line id {} updated to ACTIVE" , orderLineId);
                    updateProvisioningStatus(orderLineId,
                            Constants.PROVISIONING_STATUS_ACTIVE);
                } else {
                    logger.debug("Provisioning status of order line id {} updated to FAILED" , orderLineId);
                    updateProvisioningStatus(orderLineId,
                            Constants.PROVISIONING_STATUS_FAILED);
                }
            } else {
                updateProvisioningCommandStatus(message);
            }
        } catch (Exception e) {
            logger.error("processing mmsc provisioning command", e);
        }
    }

    private void updateProvisioningStatus(int orderLineId,
            int provisioningStatusId) {
        try {
            IProvisioningProcessSessionBean provisioning =
                    (IProvisioningProcessSessionBean) Context.getBean(
                    Context.Name.PROVISIONING_PROCESS_SESSION);

            provisioning.updateProvisioningStatus(orderLineId,
                    provisioningStatusId);
        } catch (Exception e) {
            logger.error("Exception updating orderline provisioning status id", e);
        }
    }

    private void updateProvisioningCommandStatus(MapMessage message) {
        try {

            logger.debug("Provisioning command MDB command= {} - entity= {} - Processing message by {} ",message.getStringProperty("in_command"),message.getIntProperty("in_entityId"), this.hashCode());

            MapMessage myMessage            = (MapMessage) message;

            String in_commandId_str = myMessage.getStringProperty("in_commandId");
            Integer in_commandId = null;

            String result = myMessage.getStringProperty("out_result");

            logger.debug("Message property result value : {}", result);

            try {
                in_commandId = Integer.parseInt(in_commandId_str.trim());
            } catch (Exception e) {}

            logger.debug("Message property in_commandId value : {}" , in_commandId);

            ProvisioningRequestDAS provisioningRequestDAS = new ProvisioningRequestDAS();
            ProvisioningCommandDAS provisioningCommandDAS = new ProvisioningCommandDAS();

            ProvisioningCommandDTO provisioningCommandDTO = provisioningCommandDAS.findNow(in_commandId);

            if (provisioningCommandDTO != null) {

                Integer requestsCount = provisioningRequestDAS.getRequestsCountByCommandId(in_commandId);

                Integer successfulRequestsCount = provisioningRequestDAS.getRequestByCommandIdAndStatus(in_commandId, ProvisioningRequestStatus.SUCCESSFUL);
                Integer failedRequestsCount = provisioningRequestDAS.getRequestByCommandIdAndStatus(in_commandId, ProvisioningRequestStatus.FAILED);
                Integer canceledRequestsCount = provisioningRequestDAS.getRequestByCommandIdAndStatus(in_commandId, ProvisioningRequestStatus.CANCELLED);
                Integer unavailableRequestsCount = provisioningRequestDAS.getRequestByCommandIdAndStatus(in_commandId, ProvisioningRequestStatus.UNAVAILABLE);
                Integer rollbackRequestsCount = provisioningRequestDAS.getRequestByCommandIdAndStatus(in_commandId, ProvisioningRequestStatus.ROLLBACK);

                logger.debug("Number of requests: {}; Succesfull: {}, Failed: {}. Canceled: {}, Unavailable: {}, Rollback: {}",
                        requestsCount, successfulRequestsCount, failedRequestsCount, canceledRequestsCount, unavailableRequestsCount,
                        rollbackRequestsCount);

                if (requestsCount.equals(successfulRequestsCount))
                    provisioningCommandDTO.setCommandStatus(ProvisioningCommandStatus.SUCCESSFUL);
                else if (failedRequestsCount > 0)
                    provisioningCommandDTO.setCommandStatus(ProvisioningCommandStatus.FAILED);
                else if (canceledRequestsCount > 0 || rollbackRequestsCount > 0)
                    provisioningCommandDTO.setCommandStatus(ProvisioningCommandStatus.CANCELLED);
                else if (unavailableRequestsCount > 0)
                    provisioningCommandDTO.setCommandStatus(ProvisioningCommandStatus.UNAVAILABLE);
                else {
                    logger.warn("Provisioning command status unmodified: {}" , in_commandId);
                }

                provisioningCommandDTO.setLastUpdateDate(TimezoneHelper.serverCurrentDate());
                provisioningCommandDAS.save(provisioningCommandDTO);

                CommandStatusUpdateEvent newEvent = new CommandStatusUpdateEvent(provisioningCommandDTO.getEntity().getId(), provisioningCommandDTO);
                EventManager.process(newEvent);
                logger.debug("OrExternalProvisioning: generated CommandStatusUpdateEvent for provisioning command {} status update: {}",
                        in_commandId,
                        provisioningCommandDTO.getCommandStatus());

            }  else {
                throw new SessionInternalError("Didn't find provisioning command : " + in_commandId);
            }
        } catch (Exception e) {
            throw new SessionInternalError("processing provisioning command", e);
        }
    }

    private void pause(long t) {
        logger.debug("TestExternalProvisioningMDB: pausing for {}  ms..." , t);

        try {
            Thread.sleep(t);
        } catch (InterruptedException e) {
        }
    }
}
