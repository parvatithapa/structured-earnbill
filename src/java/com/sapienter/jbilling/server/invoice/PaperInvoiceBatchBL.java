/*
 * JBILLING CONFIDENTIAL
 * _____________________
 *
 * [2003] - [2012] Enterprise jBilling Software Ltd.
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Enterprise jBilling Software.
 * The intellectual and technical concepts contained
 * herein are proprietary to Enterprise jBilling Software
 * and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden.
 */

package com.sapienter.jbilling.server.invoice;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import com.sapienter.jbilling.server.notification.MessageDTO;
import com.sapienter.jbilling.server.notification.MessageSection;
import org.apache.log4j.Logger;

import javax.sql.rowset.CachedRowSet;

import com.lowagie.text.Document;
import com.lowagie.text.DocumentException;
import com.lowagie.text.pdf.PRAcroForm;
import com.lowagie.text.pdf.PdfCopy;
import com.lowagie.text.pdf.PdfImportedPage;
import com.lowagie.text.pdf.PdfReader;
import com.lowagie.text.pdf.SimpleBookmark;
import com.sapienter.jbilling.common.FormatLogger;
import com.sapienter.jbilling.common.SessionInternalError;
import com.sapienter.jbilling.common.Util;
import com.sapienter.jbilling.server.process.db.PaperInvoiceBatchDTO;
import com.sapienter.jbilling.server.invoice.db.InvoiceDTO;
import com.sapienter.jbilling.server.notification.NotificationBL;
import com.sapienter.jbilling.server.process.BillingProcessBL;
import com.sapienter.jbilling.server.process.db.PaperInvoiceBatchDAS;
import com.sapienter.jbilling.server.user.db.CompanyDAS;
import com.sapienter.jbilling.server.util.Constants;
import com.sapienter.jbilling.server.util.PreferenceBL;
import com.sapienter.jbilling.server.util.audit.EventLogger;

/**
 * @author Emil
 */
public class PaperInvoiceBatchBL {
    private PaperInvoiceBatchDTO batch = null;
    private static final FormatLogger LOG = new FormatLogger(Logger.getLogger(PaperInvoiceBatchBL.class));
    private EventLogger eLogger = null;
    private PaperInvoiceBatchDAS batchHome = null;

    public static final String MESSAGE_PARM_COMPILE_BATCH = "compileBatch";
    public static final String MESSAGE_PARM_COMPILE_BATCH_ENTITY = "entity";
    public static final String MESSAGE_PARM_COMPILE_BATCH_PROCESS = "process";

    /** The maximum safe number of invoices to be batched.  */
    public static final Integer MAX_RESULTS = 10000;


    public PaperInvoiceBatchBL(Integer batchId) {
        init();
        set(batchId);
    }
    
    public PaperInvoiceBatchBL(PaperInvoiceBatchDTO batch) {
        init();
        this.batch = batch;
    }

    public PaperInvoiceBatchBL() {
        init();
    }

    private void init() {
        eLogger = EventLogger.getInstance();
        batchHome = new PaperInvoiceBatchDAS();
    }

    public PaperInvoiceBatchDTO getEntity() {
        return batch;
    }
    
    public void set(Integer id) {
        batch = batchHome.find(id);
    }

    /**
     * This method will create a record if there's none for the given
     * process id, otherwise it will return the existing one
     * @param processId
     * @return
     */
    public PaperInvoiceBatchDTO createGet(Integer processId) {
        BillingProcessBL process = new BillingProcessBL(processId);
        batch = process.getEntity().getPaperInvoiceBatch();
        if (batch == null) {
            Integer preferencePaperSelfDelivery = 
            	PreferenceBL.getPreferenceValueAsIntegerOrZero(
            		process.getEntity().getEntity().getId(), 
            		Constants.PREFERENCE_PAPER_SELF_DELIVERY);
            batch = batchHome.create(new Integer(0), preferencePaperSelfDelivery);
            process.getEntity().setPaperInvoiceBatch(batch);
        }
        return batch;
    }

    /**
     * Will take all the files generated by the process and 'paste' them
     * into a big one, deleting the originals.
     * This then will facilitate the printing of a batch.
     */
    public void compileInvoiceFilesForProcess(Integer entityId) 
            throws DocumentException, IOException {
        String filePrefix = Util.getSysProp("base_dir") + "invoices/" + 
            entityId + "-";
        // now go through each of the invoices
        // first - sort them
        List invoices = new ArrayList(batch.getInvoices());
        Collections.sort(invoices, new InvoiceEntityComparator());
        Integer[] invoicesIds = new Integer[invoices.size()];


        for (int f = 0; f < invoices.size(); f++) {
            InvoiceDTO invoice = (InvoiceDTO) invoices.get(f);
            invoicesIds[f] = invoice.getId();
        }
        
        compileInvoiceFiles(filePrefix, new Integer(batch.getId()).toString(), entityId,
                invoicesIds);
    }

    /**
     * Takes a list of invoices and replaces the individual PDF files for one
     * single PDF in the destination directory.
     * @param destination
     * @param prefix
     * @param entityId
     * @param invoices
     * @throws IOException
     */
    public void compileInvoiceFiles(String destination, String prefix,
            Integer entityId, Integer[] invoices)
            throws DocumentException, IOException {

        String filePrefix = Util.getSysProp("base_dir") + "invoices/"+ entityId + "-";
        String outFile = destination + prefix + "-batch.pdf";

        CompanyDAS companyDAS = new CompanyDAS();
        int pageOffset = 0;
        ArrayList master = new ArrayList();
        Document document = null;
        PdfCopy  writer = null;
        for(int f = 0; f < invoices.length ; f++) {
        	if (companyDAS.isRoot(entityId)) {
        		filePrefix = Util.getSysProp("base_dir") + "invoices/";
        		entityId = new InvoiceBL(invoices[f]).getDTO().getBaseUser().getCompany().getId();
        		filePrefix =filePrefix+ entityId + "-";
        	}
            // we create a reader for a certain document
            PdfReader reader = new PdfReader(filePrefix + invoices[f] + "-invoice.pdf" , "reports".getBytes());
            reader.consolidateNamedDestinations();
            // we retrieve the total number of pages
            int numberOfPages = reader.getNumberOfPages();
            List bookmarks = SimpleBookmark.getBookmark(reader);
            if (bookmarks != null) {
                if (pageOffset != 0)
                    SimpleBookmark.shiftPageNumbers(bookmarks, pageOffset, null);
                master.addAll(bookmarks);
            }
            pageOffset += numberOfPages;
            
            if (f == 0) {
                // step 1: creation of a document-object
                document = new Document(reader.getPageSizeWithRotation(1));
                // step 2: we create a writer that listens to the document
                writer = new PdfCopy(document, new FileOutputStream(outFile));
                // step 3: we open the document
                document.open();
            }
            // step 4: we add content
            PdfImportedPage page;
            for (int i = 0; i < numberOfPages; ) {
                ++i;
                page = writer.getImportedPage(reader, i);
                writer.addPage(page);
            }
            PRAcroForm form = reader.getAcroForm();
            if (form != null)
                writer.copyAcroForm(reader);
            
            //release and delete 
            writer.freeReader(reader);
            reader.close();
            File file = new File(filePrefix + invoices[f] + "-invoice.pdf");
            file.delete();
        }
        if (!master.isEmpty())
            writer.setOutlines(master);
        // step 5: we close the document
        if (document != null) {
            document.close();
        } else {
            LOG.warn("document == null");
        }

        LOG.debug("PDF batch file is ready %s", outFile);
    }

    
    public void sendEmail() {
        Integer entityId = batch.getProcess().getEntity().getId();
        
        int preferencePaperSelfDelivery = 
        	PreferenceBL.getPreferenceValueAsIntegerOrZero(entityId, Constants.PREFERENCE_PAPER_SELF_DELIVERY);

        String preferenceEmailRecipient =
                PreferenceBL.getPreferenceValue(entityId, Constants.PREFERENCE_EMAIL_INVOICE_BUNDLE);

        if(preferenceEmailRecipient == null || preferenceEmailRecipient.trim().isEmpty()) {
            LOG.error("No recipient is defined to receive the invoice bundle. See preference %s", Constants.PREFERENCE_EMAIL_INVOICE_BUNDLE);
            return;
        }

        Boolean selfDelivery = new Boolean(preferencePaperSelfDelivery == 1);
        // If the entity doesn't want to delivery the invoices, then
        // sapienter has to. Entity 1 is always sapienter.
        Integer pritingEntity;
        if (!selfDelivery.booleanValue()) {
            pritingEntity = new Integer(1);
        } else {
            pritingEntity = entityId;
        }
        try {
            NotificationBL.sendSapienterEmail(preferenceEmailRecipient, pritingEntity, "invoice_batch",
                    Util.getSysProp("base_dir") + "invoices/" + entityId + 
                    "-" + batch.getId() + "-batch.pdf", null);
        } catch (Exception e) {
            LOG.error("Could no send the email with the paper invoices " +
                    "for entity " + entityId, e);
        }
    }

    public String generateBatchPdf(List<InvoiceDTO> invoices, Integer entityId)
            throws SQLException,
            SessionInternalError, DocumentException,
            IOException {
        String realPath = Util.getSysProp("base_dir") + "invoices" + File.separator;

        Iterator<InvoiceDTO> iterator = invoices.iterator();
        NotificationBL notif = new NotificationBL();
        List<Integer> invoicesIdsList = new ArrayList<Integer>();

        int generated = 0;
        while (iterator.hasNext()) {
            Integer invoiceId = iterator.next().getId();
            InvoiceBL invoice = new InvoiceBL(invoiceId);
            LOG.debug("Generating paper invoice %d", invoiceId);
            notif.generatePaperInvoiceAsFile(invoice.getEntity());
            invoicesIdsList.add(invoiceId);

            // no more than 1000 invoices at a time, please
            generated++;
            if (generated >= 1000) break;
        }

        if (generated > 0) {
            // merge all these files into a single one
            String hash = String.valueOf(System.currentTimeMillis());
            Integer[] invoicesIds = new Integer[invoicesIdsList.size()];
            invoicesIdsList.toArray(invoicesIds);
            compileInvoiceFiles(realPath,
                    entityId + "-" + hash,
                    entityId,
                    invoicesIds);

            return entityId + "-" + hash + "-batch.pdf";
        } else {
            // there was no rows in that query ...
            return null;
        }
    }
    
    public String generateFile(CachedRowSet cachedRowSet, Integer entityId, 
            String realPath) throws SQLException,
            SessionInternalError, DocumentException,
            IOException {
        NotificationBL notif = new NotificationBL();
        List invoices = new ArrayList();

        int generated = 0;
        while (cachedRowSet.next()) {
            Integer invoiceId = new Integer(cachedRowSet.getInt(1));
            InvoiceBL invoice = new InvoiceBL(invoiceId);
            LOG.debug("Generating paper invoice %d", invoiceId);
            notif.generatePaperInvoiceAsFile(invoice.getEntity());
            invoices.add(invoiceId);
            
            // no more than 1000 invoices at a time, please
            generated++;
            if (generated >= 1000) break;
        }

        if (generated > 0) {
            // merge all these files into a single one
            String hash = String.valueOf(System.currentTimeMillis());
            Integer[] invoicesIds = new Integer[invoices.size()];
            invoices.toArray(invoicesIds);
            compileInvoiceFiles(realPath.substring(0, 
                    realPath.indexOf("_FILE_NAME_")) + "/", 
                    entityId + "-" + hash, entityId, invoicesIds);
    
            return entityId + "-" + hash + "-batch.pdf";
        } else {
            // there was no rows in that query ...
            return null;
        }
    }

    public static MessageDTO createCompileMessage(Integer entityId, Integer billingProcessId) {
        MessageDTO message = new MessageDTO();
        message.setTypeId(MessageDTO.TYPE_INVOICE_PAPER);
        message.getParameters().put(MESSAGE_PARM_COMPILE_BATCH, Boolean.TRUE);
        message.getParameters().put(MESSAGE_PARM_COMPILE_BATCH_ENTITY, entityId);
        message.getParameters().put(MESSAGE_PARM_COMPILE_BATCH_PROCESS, billingProcessId);
        message.addSection(new MessageSection(0, ""));
        return message;
    }

    public static Integer getBillingProcessForBatch(MessageDTO message) {
        return (Integer)message.getParameters().get(MESSAGE_PARM_COMPILE_BATCH_PROCESS);
    }

    public static Integer getEntityForBatch(MessageDTO message) {
        return (Integer)message.getParameters().get(MESSAGE_PARM_COMPILE_BATCH_ENTITY);
    }

    public static boolean isCompileMessage(MessageDTO message) {
        return Boolean.TRUE.equals(message.getParameters().get(MESSAGE_PARM_COMPILE_BATCH));
    }
}
