/*
 * JBILLING CONFIDENTIAL
 * _____________________
 *
 * [2003] - [2012] Enterprise jBilling Software Ltd.
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Enterprise jBilling Software.
 * The intellectual and technical concepts contained
 * herein are proprietary to Enterprise jBilling Software
 * and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden.
 */

package com.sapienter.jbilling.server.invoice;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.lang.invoke.MethodHandles;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

import javax.sql.rowset.CachedRowSet;

import org.apache.commons.lang.StringUtils;
import org.hibernate.SessionFactory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.lowagie.text.Document;
import com.lowagie.text.DocumentException;
import com.lowagie.text.pdf.PRAcroForm;
import com.lowagie.text.pdf.PdfCopy;
import com.lowagie.text.pdf.PdfImportedPage;
import com.lowagie.text.pdf.PdfReader;
import com.lowagie.text.pdf.PdfSmartCopy;
import com.lowagie.text.pdf.PdfStream;
import com.lowagie.text.pdf.SimpleBookmark;
import com.sapienter.jbilling.common.SessionInternalError;
import com.sapienter.jbilling.common.Util;
import com.sapienter.jbilling.server.billing.task.BulkIndexFile;
import com.sapienter.jbilling.server.billing.task.IndexFileObject;
import com.sapienter.jbilling.server.invoice.db.InvoiceDTO;
import com.sapienter.jbilling.server.mediation.custommediation.spc.SPCConstants;
import com.sapienter.jbilling.server.metafields.db.MetaFieldValue;
import com.sapienter.jbilling.server.notification.MessageDTO;
import com.sapienter.jbilling.server.notification.MessageSection;
import com.sapienter.jbilling.server.notification.NotificationBL;
import com.sapienter.jbilling.server.process.BillingProcessBL;
import com.sapienter.jbilling.server.process.db.PaperInvoiceBatchDAS;
import com.sapienter.jbilling.server.process.db.PaperInvoiceBatchDTO;
import com.sapienter.jbilling.server.user.db.CompanyDAS;
import com.sapienter.jbilling.server.user.db.CustomerAccountInfoTypeMetaField;
import com.sapienter.jbilling.server.user.db.CustomerDTO;
import com.sapienter.jbilling.server.util.Constants;
import com.sapienter.jbilling.server.util.Context;
import com.sapienter.jbilling.server.util.Context.Name;
import com.sapienter.jbilling.server.util.PreferenceBL;

/**
 * @author Emil
 */
public class PaperInvoiceBatchBL {
    private PaperInvoiceBatchDTO batch = null;
    private static final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());
    private PaperInvoiceBatchDAS batchHome = null;

    public static final String MESSAGE_PARM_COMPILE_BATCH = "compileBatch";
    public static final String MESSAGE_PARM_COMPILE_BATCH_ENTITY = "entity";
    public static final String MESSAGE_PARM_COMPILE_BATCH_PROCESS = "process";

    // Initially value as false
    private AtomicBoolean usePdfCompression = new AtomicBoolean(false);
    /** The maximum safe number of invoices to be batched.  */
    public static final Integer MAX_RESULTS = 10000;
    public static final String DOUBLE_QUOTES = "\"";


    public PaperInvoiceBatchBL(Integer batchId) {
        init();
        set(batchId);
    }

    public PaperInvoiceBatchBL(PaperInvoiceBatchDTO batch) {
        init();
        this.batch = batch;
    }

    public PaperInvoiceBatchBL() {
        init();
    }

    private void init() {
        batchHome = new PaperInvoiceBatchDAS();
    }

    public PaperInvoiceBatchDTO getEntity() {
        return batch;
    }

    public void set(Integer id) {
        batch = batchHome.find(id);
    }

    /**
     * This method will create a record if there's none for the given
     * process id, otherwise it will return the existing one
     * @param processId
     * @return
     */
    public PaperInvoiceBatchDTO createGet(Integer processId) {
        BillingProcessBL process = new BillingProcessBL(processId);
        batch = process.getEntity().getPaperInvoiceBatch();
        if (batch == null) {
            Integer preferencePaperSelfDelivery = 
                    PreferenceBL.getPreferenceValueAsIntegerOrZero(
                            process.getEntity().getEntity().getId(), 
                            Constants.PREFERENCE_PAPER_SELF_DELIVERY);
            batch = batchHome.create(new Integer(0), preferencePaperSelfDelivery);
            process.getEntity().setPaperInvoiceBatch(batch);
        }
        return batch;
    }

    /**
     * Will take all the files generated by the process and 'paste' them
     * into a big one, deleting the originals.
     * This then will facilitate the printing of a batch.
     */
    public void compileInvoiceFilesForProcess(Integer entityId) 
            throws DocumentException, IOException {
        String filePrefix = Util.getSysProp("base_dir") + "invoices/" + 
                entityId + "-";
        // now go through each of the invoices
        // first - sort them
        List invoices = new ArrayList(batch.getInvoices());
        Collections.sort(invoices, new InvoiceEntityComparator());
        Integer[] invoicesIds = new Integer[invoices.size()];


        for (int f = 0; f < invoices.size(); f++) {
            InvoiceDTO invoice = (InvoiceDTO) invoices.get(f);
            invoicesIds[f] = invoice.getId();
        }

        compileInvoiceFiles(filePrefix, new Integer(batch.getId()).toString(), entityId,
                invoicesIds);
    }

    /**
     * Takes a list of invoices and replaces the individual PDF files for one
     * single PDF in the destination directory.
     * @param destination
     * @param prefix
     * @param entityId
     * @param invoices
     * @throws IOException
     */
    public void compileInvoiceFiles(String destination, String prefix,
            Integer entityId, Integer[] invoices)
                    throws DocumentException, IOException {

        String filePrefix = Util.getSysProp("base_dir") + "invoices/"+ entityId + "-";
        String outFile = destination + prefix + "-batch.pdf";

        CompanyDAS companyDAS = new CompanyDAS();
        int pageOffset = 0;
        ArrayList master = new ArrayList();
        Document document = null;
        PdfCopy  writer = null;
        for(int f = 0; f < invoices.length ; f++) {
            if (companyDAS.isRoot(entityId)) {
                filePrefix = Util.getSysProp("base_dir") + "invoices/";
                entityId = new InvoiceBL(invoices[f]).getDTO().getBaseUser().getCompany().getId();
                filePrefix =filePrefix+ entityId + "-";
            }
            // we create a reader for a certain document
            PdfReader reader = new PdfReader(filePrefix + invoices[f] + "-invoice.pdf" , "reports".getBytes());
            reader.consolidateNamedDestinations();
            // we retrieve the total number of pages
            int numberOfPages = reader.getNumberOfPages();
            List bookmarks = SimpleBookmark.getBookmark(reader);
            if (bookmarks != null) {
                if (pageOffset != 0)
                    SimpleBookmark.shiftPageNumbers(bookmarks, pageOffset, null);
                master.addAll(bookmarks);
            }
            pageOffset += numberOfPages;

            if (f == 0) {
                // step 1: creation of a document-object
                document = new Document(reader.getPageSizeWithRotation(1));
                // step 2: we create a writer that listens to the document
                writer = usePdfCompression.get() ? new PdfSmartCopy(document, new FileOutputStream(outFile)) : new PdfCopy(document, new FileOutputStream(outFile));
                // step 3: we open the document
                document.open();
            }
            // step 4: we add content
            PdfImportedPage page;
            for (int i = 0; i < numberOfPages; ) {
                ++i;
                page = writer.getImportedPage(reader, i);
                writer.addPage(page);
            }
            PRAcroForm form = reader.getAcroForm();
            if (form != null)
                writer.copyAcroForm(reader);
            if (usePdfCompression.get()) {
                writer.setFullCompression();
                writer.setCompressionLevel(PdfStream.BEST_COMPRESSION);
			}

            //release and delete 
            writer.freeReader(reader);
            reader.close();
            File file = new File(filePrefix + invoices[f] + "-invoice.pdf");
            file.delete();
        }
        if (!master.isEmpty())
            writer.setOutlines(master);
        // step 5: we close the document
        if (document != null) {
            document.close();
        } else {
            logger.warn("document == null");
        }

        logger.debug("PDF batch file is ready {}", outFile);
    }


    public void sendEmail() {
        Integer entityId = batch.getProcess().getEntity().getId();

        int preferencePaperSelfDelivery = 
                PreferenceBL.getPreferenceValueAsIntegerOrZero(entityId, Constants.PREFERENCE_PAPER_SELF_DELIVERY);

        String preferenceEmailRecipient =
                PreferenceBL.getPreferenceValue(entityId, Constants.PREFERENCE_EMAIL_INVOICE_BUNDLE);

        if(preferenceEmailRecipient == null || preferenceEmailRecipient.trim().isEmpty()) {
            logger.error("No recipient is defined to receive the invoice bundle. See preference {}", Constants.PREFERENCE_EMAIL_INVOICE_BUNDLE);
            return;
        }

        Boolean selfDelivery = new Boolean(preferencePaperSelfDelivery == 1);
        // If the entity doesn't want to delivery the invoices, then
        // sapienter has to. Entity 1 is always sapienter.
        Integer pritingEntity;
        if (!selfDelivery.booleanValue()) {
            pritingEntity = new Integer(1);
        } else {
            pritingEntity = entityId;
        }
        try {
            NotificationBL.sendSapienterEmail(preferenceEmailRecipient, pritingEntity, "invoice_batch",
                    Util.getSysProp("base_dir") + "invoices/" + entityId + 
                    "-" + batch.getId() + "-batch.pdf", null);
        } catch (Exception e) {
            logger.error("Could no send the email with the paper invoices " +
                    "for entity " + entityId, e);
        }
    }

    public String generateBatchPdf(List<InvoiceDTO> invoices, Integer entityId)
            throws SQLException,
            SessionInternalError, DocumentException,
            IOException {
        String realPath = Util.getSysProp("base_dir") + "invoices" + File.separator;

        Iterator<InvoiceDTO> iterator = invoices.iterator();
        NotificationBL notif = new NotificationBL();
        List<Integer> invoicesIdsList = new ArrayList<Integer>();

        int generated = 0;
        while (iterator.hasNext()) {
            Integer invoiceId = iterator.next().getId();
            InvoiceBL invoice = new InvoiceBL(invoiceId);
            logger.debug("Generating paper invoice {}", invoiceId);
            notif.generatePaperInvoiceAsFile(invoice.getEntity());
            invoicesIdsList.add(invoiceId);

            // no more than 1000 invoices at a time, please
            generated++;
            if (generated >= 1000) break;
        }

        if (generated > 0) {
            // merge all these files into a single one
            String hash = String.valueOf(System.currentTimeMillis());
            Integer[] invoicesIds = new Integer[invoicesIdsList.size()];
            invoicesIdsList.toArray(invoicesIds);
            compileInvoiceFiles(realPath,
                    entityId + "-" + hash,
                    entityId,
                    invoicesIds);

            return entityId + "-" + hash + "-batch.pdf";
        } else {
            // there was no rows in that query ...
            return null;
        }
    }

    public BulkIndexFile generateSPCBatchPdf(List<Integer> invoices, Integer entityId, boolean useCompression)
            throws SQLException, DocumentException, IOException {

        usePdfCompression.set(useCompression);
        BulkIndexFile bulkIndexFile = new BulkIndexFile();
        List<IndexFileObject> indexFileObjects = new ArrayList<>();
        String realPath = Util.getSysProp("base_dir") + "invoices" + File.separator;

        NotificationBL notif = new NotificationBL();
        List<Integer> invoicesIdsList = new ArrayList<Integer>();
        List<IndexFileObject> failedIdsList = new ArrayList<IndexFileObject>();
        int pageOffset = 0;
        int generated = 0;
        for (Integer invoiceId : invoices) {
            logger.debug("Generating paper invoice {}", invoiceId);
            long start = System.currentTimeMillis();
            InvoiceDTO invoiceDTO = new InvoiceBL(invoiceId).getEntity();
            int numberOfPages;
            try {
                numberOfPages = new PdfReader(notif.generatePaperInvoiceAsFile(invoiceDTO)).getNumberOfPages();
                logger.debug("Generating paper invoice {} with pageOffset {} and number of pages {}", invoiceId,
                        pageOffset, numberOfPages);
            } catch (Exception e) {
            logger.debug("Exception in generating individual invoice : {} ", e.getMessage());
                IndexFileObject indexFileObject = getIndexFileObject(invoiceDTO);
                indexFileObject.setFileName(StringUtils.EMPTY);
                indexFileObject.setStartImpression(Integer.valueOf(0));
                indexFileObject.setEndImpression(Integer.valueOf(0));
                failedIdsList.add(indexFileObject);
                continue;
            }
            long end = System.currentTimeMillis();
            logger.debug("Generating InvoiceAsFile took {} ms", (end - start));
            invoicesIdsList.add(invoiceId);
            IndexFileObject indexFileObject = getIndexFileObject(invoiceDTO);
            if (pageOffset < 1) {
                indexFileObject.setStartImpression(1);
            } else {
                indexFileObject.setStartImpression(pageOffset + 1);
            }
            indexFileObject.setEndImpression(pageOffset + numberOfPages);
            pageOffset += numberOfPages;
            indexFileObjects.add(indexFileObject);
            // no more than 1000 invoices at a time, please
            if (generated % 100 == 0) {
                SessionFactory sf = Context.getBean(Name.HIBERNATE_SESSION);
                sf.getCurrentSession().clear();
            }
            generated++;
            if (generated >= 1000) {
                break;
            }
        }
        if (generated > 0) {
            // merge all these files into a single one
            String hash = String.valueOf(System.currentTimeMillis());
            Integer[] invoicesIds = new Integer[invoicesIdsList.size()];
            invoicesIdsList.toArray(invoicesIds);
            compileInvoiceFiles(realPath,
                    entityId + "-" + hash,
                    entityId,
                    invoicesIds);

            String originalFileName = entityId + "-" + hash + "-batch.pdf";
            System.out.println("bulkIndexFile : " + bulkIndexFile);
            bulkIndexFile.setIndexFileObjects(indexFileObjects);
            bulkIndexFile.setOriginalFileName(originalFileName);
            bulkIndexFile.setFailedFileObjects(failedIdsList);
            return bulkIndexFile;
        } else {
        	bulkIndexFile.setFailedFileObjects(failedIdsList);
           return bulkIndexFile;
        }
    }

    private IndexFileObject getIndexFileObject(InvoiceDTO invoice) {
        String[] metaFieldArray = {SPCConstants.PO_BOX,SPCConstants.SUB_PREMISES,SPCConstants.STREET_NUMBER,
                SPCConstants.STREET_NAME, SPCConstants.STREET_TYPE,SPCConstants.CITY,SPCConstants.STATE,SPCConstants.POST_CODE};
        CustomerDTO customer = invoice.getBaseUser().getCustomer();
        IndexFileObject fileObject = new IndexFileObject();
        StringBuilder address = new StringBuilder();

        CustomerAccountInfoTypeMetaField[] metaFieldArrayValue = new CustomerAccountInfoTypeMetaField[metaFieldArray.length];

        for (int i =0;i < metaFieldArray.length;i++) {
            metaFieldArrayValue[i] = customer.getCustomerAccountInfoTypeMetaField(metaFieldArray[i], SPCConstants.SPC_BILLING_ADDRESS_GROUP_ID);
        }

        for (int i =0;i < metaFieldArrayValue.length;i++) {
            if (null != metaFieldArrayValue[i]) {
                address.append((String)metaFieldArrayValue[i].getMetaFieldValue().getValue()).append(SPCConstants.SEPARATOR);
            }
        }

        fileObject.setAddress(StringUtils.isNotBlank(address.toString()) ? new StringBuilder(DOUBLE_QUOTES).append(address).append(DOUBLE_QUOTES) : new StringBuilder(StringUtils.EMPTY));
        String crmAccountNumber = null;

        for (MetaFieldValue customerMetafield : customer.getMetaFields()) {
            if(null != customerMetafield
                    && null != customerMetafield.getValue()
                    && null != customerMetafield.getField()
                    && customerMetafield.getField().getName().equalsIgnoreCase("crmAccountNumber")) {
                crmAccountNumber = customerMetafield.getValue().toString();
                break;
            }
        }
        fileObject.setCrmAccountNumber(StringUtils.isNotBlank(crmAccountNumber) ? crmAccountNumber : StringUtils.EMPTY);
        fileObject.setUserId(invoice.getUserId());
        fileObject.setInvoiceId(invoice.getId());
        fileObject.setInvoiceNumber(invoice.getPublicNumber());

        return fileObject;

    }

    public String generateFile(CachedRowSet cachedRowSet, Integer entityId, 
            String realPath) throws SQLException,
            SessionInternalError, DocumentException,
            IOException {
        NotificationBL notif = new NotificationBL();
        List invoices = new ArrayList();

        int generated = 0;
        while (cachedRowSet.next()) {
            Integer invoiceId = new Integer(cachedRowSet.getInt(1));
            InvoiceBL invoice = new InvoiceBL(invoiceId);
            logger.debug("Generating paper invoice {}", invoiceId);
            notif.generatePaperInvoiceAsFile(invoice.getEntity());
            invoices.add(invoiceId);

            // no more than 1000 invoices at a time, please
            generated++;
            if (generated >= 1000) break;
        }

        if (generated > 0) {
            // merge all these files into a single one
            String hash = String.valueOf(System.currentTimeMillis());
            Integer[] invoicesIds = new Integer[invoices.size()];
            invoices.toArray(invoicesIds);
            compileInvoiceFiles(realPath.substring(0, 
                    realPath.indexOf("_FILE_NAME_")) + "/", 
                    entityId + "-" + hash, entityId, invoicesIds);

            return entityId + "-" + hash + "-batch.pdf";
        } else {
            // there was no rows in that query ...
            return null;
        }
    }

    public static MessageDTO createCompileMessage(Integer entityId, Integer billingProcessId) {
        MessageDTO message = new MessageDTO();
        message.setTypeId(MessageDTO.TYPE_INVOICE_PAPER);
        message.getParameters().put(MESSAGE_PARM_COMPILE_BATCH, Boolean.TRUE);
        message.getParameters().put(MESSAGE_PARM_COMPILE_BATCH_ENTITY, entityId);
        message.getParameters().put(MESSAGE_PARM_COMPILE_BATCH_PROCESS, billingProcessId);
        message.addSection(new MessageSection(0, ""));
        return message;
    }

    public static Integer getBillingProcessForBatch(MessageDTO message) {
        return (Integer)message.getParameters().get(MESSAGE_PARM_COMPILE_BATCH_PROCESS);
    }

    public static Integer getEntityForBatch(MessageDTO message) {
        return (Integer)message.getParameters().get(MESSAGE_PARM_COMPILE_BATCH_ENTITY);
    }

    public static boolean isCompileMessage(MessageDTO message) {
        return Boolean.TRUE.equals(message.getParameters().get(MESSAGE_PARM_COMPILE_BATCH));
    }
}