pipeline {
    agent any

    environment {
        PORT_MAPPING= "8080:8080"
        JMX_PORT_MAPPING= "9090:9090"

        MOUNT_JBILLING_HOME= "/home/jbilling/billinghub/jbilling-home:/home/billinghub/jbilling-home"
        MOUNT_LOG_LOCATION= "/home/jbilling/billinghub/logs/jbilling:/home/billinghub/logs"

        CONTAINER_NAME = "billinghub-jbilling"
        REPO_CONTAINER_NAME = "10.6.0.1:8082/billinghub-jbilling"
        IMAGE_TAG = "192.168.1.119:8082/billinghub-jbilling:${params.IMAGE_TAG}"
        RE_TAG = "${REPO_CONTAINER_NAME}:${params.IMAGE_TAG}"

        JBILLING_DB_HOST = "10.6.0.4"
        JBILLING_DB_PORT = "7432"

        JBILLING_DB_NAME = "jbilling_test"
        CRED_JBILLING_DB= credentials('db-adennet-billinghub')
        JBILLING_DB_USER = "$CRED_JBILLING_DB_USR"
        JBILLING_DB_PASSWORD = "$CRED_JBILLING_DB_PSW"

        JBILLING_SERVER_URL = "http://10.6.0.2/jbilling"
        SPRING_PROFILES_ACTIVE = "billing.master,mediation.slave"

        UMS_DB_NAME = "billinghub_usage_management_db"
        CRED_UMS_DB= credentials('db-adennet-billinghub')
        UMS_DB_USER = "$CRED_UMS_DB_USR"
        UMS_DB_PASSWORD = "$CRED_UMS_DB_PSW"

        DOCKER_REG_HOST= "http://10.6.0.1:8082"
        CRED_DOCKER_REG= credentials('docker-registry')
        DOCKER_USERNAME= "$CRED_DOCKER_REG_USR"
        DOCKER_PASSWORD= "$CRED_DOCKER_REG_PSW"

        JAVA_OPTS="'-Xms4096m -Xmx8192m -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.port=9090 -Dcom.sun.management.jmxremote.rmi.port=9090 -Djava.rmi.server.hostname=localhost'"
    }

    stages {
        stage("Push image from Sarathi's registry to Adennet registry") {
            steps {
                script {
                    echo "Login to Sarathi's registry"
                    sh "docker login http://192.168.1.119:8082 -u ${DOCKER_USERNAME} -p ${DOCKER_PASSWORD}"

                    echo "Pulling image from Sarathi's registry"
                    sh "docker pull ${IMAGE_TAG}"
                }
            }
        }
        stage("Push image to Adennet's docker registry") {
            steps {
                script {
                    echo "Re-tagging image ${IMAGE_TAG} to ${RE_TAG}"
                    sh "docker tag ${IMAGE_TAG} ${RE_TAG} "

                    echo "Login to Adennet's registry"
                    sh "docker login ${DOCKER_REG_HOST} -u ${DOCKER_USERNAME} -p ${DOCKER_PASSWORD}"

                    echo "Pushing image ${RE_TAG} to Adennet's Docker registry "
                    sh "docker push ${RE_TAG}"
                }
            }
        }
        stage('Deploy to 10.6.0.1') {
            when {
                expression { params.DEPLOY_TO_SERVER_1 }
            }
            steps {
                script {
                    def remote = [:]
                    remote.name = "server-10.6.0.1"
                    remote.host = "10.6.0.1"
                    remote.allowAnyHosts = true
                    def imagesToRemove

                    withCredentials([usernamePassword(credentialsId: 'ssh-adennet-server', usernameVariable: 'USERNAME_SSH', passwordVariable: 'PASSWORD_SSH')]) {

                        remote.user = USERNAME_SSH
                        remote.password=PASSWORD_SSH

                        echo "Login to Docker registry(${DOCKER_REG_HOST})"
                        sshCommand remote: remote, command: "docker login ${DOCKER_REG_HOST}"

                        echo "Pulling docker image ${RE_TAG}"
                        sshCommand remote: remote, command: "docker pull ${RE_TAG}"

                        echo "Stopping existing container"
                        sshCommand remote: remote, command: "docker ps -f name=${CONTAINER_NAME} -q | xargs --no-run-if-empty docker stop"

                        echo "Removing old container if any"
                        sshCommand remote: remote, command: "docker ps -a -f name=${CONTAINER_NAME} -q | xargs --no-run-if-empty docker rm"

                        echo "Starting docker container..."
                        sshCommand remote: remote, command: "docker run -dt --restart=always --add-host=host.docker.internal:host-gateway -e JAVA_OPTS=${JAVA_OPTS} -e JBILLING_DB_HOST=${JBILLING_DB_HOST} -e JBILLING_DB_PORT=${JBILLING_DB_PORT} -e JBILLING_DB_NAME=${JBILLING_DB_NAME} -e JBILLING_DB_USER=${JBILLING_DB_USER} -e JBILLING_DB_PASSWORD=${JBILLING_DB_PASSWORD} -e JBILLING_SERVER_URL=${JBILLING_SERVER_URL} -e SPRING_PROFILES_ACTIVE=${SPRING_PROFILES_ACTIVE} -e JBILLING_DB_HOST_MEDIATION4=${JBILLING_DB_HOST} -e UMS_DB_NAME=${UMS_DB_NAME} -e UMS_DB_USER=${UMS_DB_USER} -e UMS_DB_PASSWORD=${UMS_DB_PASSWORD} -v ${MOUNT_JBILLING_HOME} -v ${MOUNT_LOG_LOCATION} --name ${CONTAINER_NAME} -p ${PORT_MAPPING} -p ${JMX_PORT_MAPPING} ${RE_TAG}"

                        echo "Removing all older images except latest 3 images"
                        imagesToRemove = sshCommand(remote: remote, command: "docker images --format '{{.Repository}}:{{.Tag}} {{.CreatedAt}}' | grep ${REPO_CONTAINER_NAME} | sort -k 2 -r | tail -n +4 | awk '{print \$1}'")

                        if(!imagesToRemove.isEmpty()) {
                            imagesToRemove.split('\n').each { image ->
                                sshCommand remote: remote, command: "docker rmi -f ${image}"
                             }
                        } else {
                            echo "No images to remove"
                        }

                        echo "Sending notification on slack channel"
                        if (currentBuild.resultIsBetterOrEqualTo('SUCCESS')) {
                            slackSend color: '#36a64f', message: "Job : Deployment of ${CONTAINER_NAME}:${params.IMAGE_TAG} on 10.6.0.1\nStatus : *SUCCESS*\nBuild Report: ${env.BUILD_URL}CI-Build-HTML-Report"
                        } else {
                            slackSend color: '#ff0000', message: "Job : Deployment of ${CONTAINER_NAME}:${params.IMAGE_TAG} on 10.6.0.1\nStatus : *FAILURE*\nBuild Report: ${env.BUILD_URL}CI-Build-HTML-Report"
                        }
                    }
                }
            }
        }
        stage('Deploy to 10.6.0.2') {
            when {
                expression { params.DEPLOY_TO_SERVER_2 }
            }
            steps {
                script {
                    def remote = [:]
                    remote.name = "server-10.6.0.2"
                    remote.host = "10.6.0.2"
                    remote.allowAnyHosts = true
                    def imagesToRemove

                    withCredentials([usernamePassword(credentialsId: 'ssh-adennet-server', usernameVariable: 'USERNAME_SSH', passwordVariable: 'PASSWORD_SSH')]) {

                        remote.user = USERNAME_SSH
                        remote.password=PASSWORD_SSH

                        echo "Login to Docker registry(${DOCKER_REG_HOST})"
                        sshCommand remote: remote, command: "docker login ${DOCKER_REG_HOST}"

                        echo "Pulling docker image ${RE_TAG}"
                        sshCommand remote: remote, command: "docker pull ${RE_TAG}"

                        echo "Stopping existing container"
                        sshCommand remote: remote, command: "docker ps -f name=${CONTAINER_NAME} -q | xargs --no-run-if-empty docker stop"

                        echo "Removing old container if any"
                        sshCommand remote: remote, command: "docker ps -a -f name=${CONTAINER_NAME} -q | xargs --no-run-if-empty docker rm"

                        echo "Starting docker container..."
                        sshCommand remote: remote, command: "docker run -dt --restart=always --add-host=host.docker.internal:host-gateway -e JAVA_OPTS=${JAVA_OPTS} -e JBILLING_DB_HOST=${JBILLING_DB_HOST} -e JBILLING_DB_PORT=${JBILLING_DB_PORT} -e JBILLING_DB_NAME=${JBILLING_DB_NAME} -e JBILLING_DB_USER=${JBILLING_DB_USER} -e JBILLING_DB_PASSWORD=${JBILLING_DB_PASSWORD} -e JBILLING_SERVER_URL=${JBILLING_SERVER_URL} -e SPRING_PROFILES_ACTIVE=${SPRING_PROFILES_ACTIVE} -e JBILLING_DB_HOST_MEDIATION4=${JBILLING_DB_HOST} -e UMS_DB_NAME=${UMS_DB_NAME} -e UMS_DB_USER=${UMS_DB_USER} -e UMS_DB_PASSWORD=${UMS_DB_PASSWORD} -v ${MOUNT_JBILLING_HOME} -v ${MOUNT_LOG_LOCATION} --name ${CONTAINER_NAME} -p ${PORT_MAPPING} -p ${JMX_PORT_MAPPING} ${RE_TAG}"

                        echo "Removing all older images except latest 3 images"
                        imagesToRemove = sshCommand(remote: remote, command: "docker images --format '{{.Repository}}:{{.Tag}} {{.CreatedAt}}' | grep ${REPO_CONTAINER_NAME} | sort -k 2 -r | tail -n +4 | awk '{print \$1}'")

                        if(!imagesToRemove.isEmpty()) {
                            imagesToRemove.split('\n').each { image ->
                                sshCommand remote: remote, command: "docker rmi -f ${image}"
                             }
                        } else {
                            echo "No images to remove"
                        }

                        echo "Sending notification on slack channel"
                        if (currentBuild.resultIsBetterOrEqualTo('SUCCESS')) {
                            slackSend color: '#36a64f', message: "Job : Deployment of ${CONTAINER_NAME}:${params.IMAGE_TAG} on 10.6.0.2\nStatus : *SUCCESS*\nBuild Report: ${env.BUILD_URL}CI-Build-HTML-Report"
                        } else {
                            slackSend color: '#ff0000', message: "Job : Deployment of ${CONTAINER_NAME}:${params.IMAGE_TAG} on 10.6.0.2\nStatus : *FAILURE*\nBuild Report: ${env.BUILD_URL}CI-Build-HTML-Report"
                        }
                    }
                }
            }
        }
    }
}
